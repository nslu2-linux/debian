---
 debian/patches/bugfix/arm/nas100d-artop-temp-fix.patch |   49 ++++++++++++++
 debian/patches/features/arm/nas100d-eth-mac.patch      |   56 +++++++++++++++++
 debian/patches/features/arm/nas100d-setup-mac.patch    |   40 ++++++++++++
 debian/patches/series/1~experimental.1                 |    3 
 4 files changed, 148 insertions(+)

Index: linux-2.6-2.6.19/debian/patches/features/arm/nas100d-eth-mac.patch
===================================================================
--- /dev/null
+++ linux-2.6-2.6.19/debian/patches/features/arm/nas100d-eth-mac.patch
@@ -0,0 +1,56 @@
+---
+ arch/arm/mach-ixp4xx/nas100d-setup.c |   27 +++++++++++++++++++++++++++
+ 1 file changed, 27 insertions(+)
+
+Index: linux-2.6.19/arch/arm/mach-ixp4xx/nas100d-setup.c
+===================================================================
+--- linux-2.6.19.orig/arch/arm/mach-ixp4xx/nas100d-setup.c
++++ linux-2.6.19/arch/arm/mach-ixp4xx/nas100d-setup.c
+@@ -16,6 +16,7 @@
+ #include <linux/serial.h>
+ #include <linux/serial_8250.h>
+ #include <linux/leds.h>
++#include <linux/mtd/mtd.h>
+ 
+ #include <asm/mach-types.h>
+ #include <asm/mach/arch.h>
+@@ -165,6 +166,30 @@ static struct platform_device *nas100d_d
+ 	&nas100d_npe_ucode,
+ };
+ 
++static void nas100d_flash_add(struct mtd_info *mtd)
++{
++	if (strcmp(mtd->name, "RedBoot config") == 0) {
++		size_t retlen;
++		u_char mac[6];
++
++		if (mtd->read(mtd, 0x0FD8, 6, &retlen, mac) == 0 && retlen == 6) {
++			printk(KERN_INFO "nas100d mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
++				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
++			memcpy(plat_mac0.hwaddr, mac, 6);
++		} else {
++			printk(KERN_ERR "nas100d mac: read failed\n");
++		}
++	}
++}
++
++static void nas100d_flash_remove(struct mtd_info *mtd) {
++}
++
++static struct mtd_notifier nas100d_flash_notifier = {
++	.add = nas100d_flash_add,
++	.remove = nas100d_flash_remove,
++};
++
+ static void nas100d_power_off(void)
+ {
+ 	/* This causes the box to drop the power and go dead. */
+@@ -196,6 +221,8 @@ static void __init nas100d_init(void)
+ 	(void)platform_device_register(&nas100d_uart);
+ 
+ 	platform_add_devices(nas100d_devices, ARRAY_SIZE(nas100d_devices));
++
++	register_mtd_user(&nas100d_flash_notifier);
+ }
+ 
+ MACHINE_START(NAS100D, "Iomega NAS 100d")
Index: linux-2.6-2.6.19/debian/patches/features/arm/nas100d-setup-mac.patch
===================================================================
--- /dev/null
+++ linux-2.6-2.6.19/debian/patches/features/arm/nas100d-setup-mac.patch
@@ -0,0 +1,40 @@
+Index: linux-2.6.19/arch/arm/mach-ixp4xx/nas100d-setup.c
+===================================================================
+--- linux-2.6.19.orig/arch/arm/mach-ixp4xx/nas100d-setup.c
++++ linux-2.6.19/arch/arm/mach-ixp4xx/nas100d-setup.c
+@@ -123,12 +123,35 @@ static struct platform_device nas100d_ua
+ 	.resource		= nas100d_uart_resources,
+ };
+ 
++static struct resource res_mac0 = {
++       .start          = IXP4XX_EthB_BASE_PHYS,
++       .end            = IXP4XX_EthB_BASE_PHYS + 0x1ff,
++       .flags          = IORESOURCE_MEM,
++};
++
++static struct mac_plat_info plat_mac0 = {
++       .npe_id         = 1,
++       .phy_id         = 0,
++       .eth_id         = 0,
++       .rxq_id         = 27,
++       .txq_id         = 24,
++};
++
++static struct platform_device mac0 = {
++       .name           = "ixp4xx_mac",
++       .id             = 0,
++       .dev.platform_data = &plat_mac0,
++       .num_resources  = 1,
++       .resource       = &res_mac0,
++};
++
+ static struct platform_device *nas100d_devices[] __initdata = {
+ 	&nas100d_i2c_controller,
+ 	&nas100d_flash,
+ #ifdef CONFIG_LEDS_IXP4XX
+ 	&nas100d_leds,
+ #endif
++	&mac0
+ };
+ 
+ static void nas100d_power_off(void)
Index: linux-2.6-2.6.19/debian/patches/series/1~experimental.1
===================================================================
--- linux-2.6-2.6.19.orig/debian/patches/series/1~experimental.1
+++ linux-2.6-2.6.19/debian/patches/series/1~experimental.1
@@ -23,8 +23,11 @@
 + features/powerpc/efika/0012-Backport-of_platform.diff
 
 + bugfix/arm/nslu2-disk-leds.patch
++ bugfix/arm/nas100d-artop-temp-fix.patch
 + features/arm/nslu2-setup-mac.patch
 + features/arm/nslu2-eth-mac.patch
++ features/arm/nas100d-setup-mac.patch
++ features/arm/nas100d-eth-mac.patch
 + features/arm/ixp4xx-0.2.1-driver.patch
 + features/arm/ixp4xx-net-driver-fix-qmgr.patch
 + features/arm/ixp4xx-net-driver-improve-mac-handling.patch
Index: linux-2.6-2.6.19/debian/patches/bugfix/arm/nas100d-artop-temp-fix.patch
===================================================================
--- /dev/null
+++ linux-2.6-2.6.19/debian/patches/bugfix/arm/nas100d-artop-temp-fix.patch
@@ -0,0 +1,49 @@
+From: Alan Cox <alan@redhat.com>
+To: Alessandro Zummo <alessandro.zummo@towertech.it>
+Cc: Jeff Garzik <jgarzik@redhat.com>, Alan Cox <alan@redhat.com>
+Subject: Re: drivers/ata/pata_artop.c
+Date: Sun, 15 Oct 2006 14:25:16 -0400
+User-Agent: Mutt/1.4.1i
+
+On Sun, Oct 15, 2006 at 07:18:31PM +0200, Alessandro Zummo wrote:
+>  In the discovery phase there's a lot of time spent in the detection
+>  of the second port.  
+
+The error recovery is a bit determined right now - Tejun's been doing some
+work on SRST behaviour and also for the worst cases polled detect so it
+should come out ok
+
+>  What's the correct way to inform the driver
+>  to avoid checking the second port?  
+
+Set the number of ports to 1 in your own tree for now. The real fix is
+not to go poking at pata ports if the ret is 0xFF
+
+---
+ drivers/ata/pata_artop.c |    6 ++++++
+ 1 file changed, 6 insertions(+)
+
+Index: linux-2.6.19/drivers/ata/pata_artop.c
+===================================================================
+--- linux-2.6.19.orig/drivers/ata/pata_artop.c
++++ linux-2.6.19/drivers/ata/pata_artop.c
+@@ -26,6 +26,7 @@
+ #include <scsi/scsi_host.h>
+ #include <linux/libata.h>
+ #include <linux/ata.h>
++#include <asm/mach-types.h>
+ 
+ #define DRV_NAME	"pata_artop"
+ #define DRV_VERSION	"0.4.2"
+@@ -469,6 +470,11 @@ static int artop_init_one (struct pci_de
+ 		pci_read_config_byte(pdev, 0x4a, &reg);
+ 		pci_write_config_byte(pdev, 0x4a, (reg & ~0x01) | 0x80);
+ 
++		/* NAS100D workaround */
++#ifdef CONFIG_MACH_NAS100D
++		if (machine_is_nas100d())
++			ports = 1;
++#endif
+ 	}
+ 
+ 	BUG_ON(info == NULL);
